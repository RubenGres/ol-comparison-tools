/**
* Author: Thomas Tilak
* github: https://github.com/thhomas/ol-comparison-tools
* licence: MIT
*/

const ComparisonTools=function(e){e||(e={});let t=this;this.controls_=[],this.clonedMap_,this.clonedLayer_,this.rightLayer_,this.leftLayer_,this.useCloneLayer_=!1,this.layerGroup_,this.vSwipeControl_,this.hSwipeControl_,BarControl.call(this,{group:!0,toggleOne:!0,className:e.className,controls:this.controls_});let o=e.controlNames||["hSlider","vSlider","scope","clipLayer","doubleMap"];e.rightLayer&&(this.rightLayer_=e.rightLayer),e.leftLayer&&(this.leftLayer_=e.leftLayer),e.layerGroup&&(this.layerGroup_=e.layerGroup),this.useCloneLayer_=!0===e.useCloneLayer&&e.useCloneLayer;for(let e=0;e<o.length;e++){let i=o[e];if("vSlider"===i){let e=new ToggleControl({html:'<i class="fa fa-arrows-v"></i>',className:"vertical-button",title:"Comparaison verticale",active:!1});e.set("name",i+"Toggle"),e.on("change:active",function(e){t.onVerticalControlChange_(e,t)}),this.addControl(e)}else if("hSlider"===i){let e=new ToggleControl({html:'<i class="fa fa-arrows-h"></i>',className:"horizontal-button",title:"Comparaison horizontale",active:!1});e.set("name",i+"Toggle"),e.on("change:active",function(e){t.onHorizontalControlChange_(e,t)}),this.addControl(e)}else if("scope"===i){let e=new ToggleControl({html:'<i class="fa fa-circle-o"></i>',className:"scope-button",name:"scope",title:"Loupe",active:!1});e.set("name",i+"Toggle"),e.on("change:active",function(e){t.onScopeControlChange_(e,t)}),this.addControl(e)}else if("clipLayer"===i){let e=new ToggleControl({html:'<i class="fa fa-eye"></i>',className:"clipLayer-button",title:"Masquer",active:!1});e.set("name",i+"Toggle"),e.on("change:active",function(e){t.onClipLayerControlChange_(e,t)}),this.addControl(e)}else if("doubleMap"===i){let e=new ToggleControl({html:'<i class="fa fa-pause"></i>',className:"doubleMap-button",name:"doubleMap",title:"Double affichage",active:!1});e.set("name",i+"Toggle"),e.on("change:active",function(e){t.onDoubleMapControlChange_(e,t)}),this.addControl(e)}}};inherits(ComparisonTools,BarControl),ComparisonTools.prototype.setMap=function(e){if(BarControl.prototype.setMap.call(this,e),this.layerGroup_||(this.layerGroup_=this.getMap().getLayerGroup()),this.getControl("doubleMapToggle")){let t=e.getViewport().parentElement,o=t.id;if(void 0===o)throw new EvalError("ol.Map div must have an id.");let i=document.createElement("div");i.id=o+"-cloned",i.hidden=!0,t.parentElement.appendChild(i),this.clonedMap_=new Map({target:i,renderer:e.getRenderer(),interactions:defaultInteractions(),view:e.getView(),controls:[new ZoomControl({zoomInTipLabel:"Zoom avant",zoomOutTipLabel:"Zoom arri√®re"}),new RotateControl,new AttributionControl]}),e.addInteraction(new SynchronizeInteraction({maps:[this.clonedMap_]})),this.clonedMap_.addInteraction(new SynchronizeInteraction({maps:[e]}))}},ComparisonTools.prototype.getControl=function(e){for(let t=0;t<this.getControls().length;t++)if(this.getControls()[t].get("name")===e)return this.getControls()[t]},ComparisonTools.prototype.onVerticalControlChange_=function(e){e.active?(this.vSwipeControl_=new SwipeControl({layers:this.getLeftLayer(),rightLayers:this.getRightLayer(),orientation:"vertical"}),this.vSwipeControl_.set("name","vSlider"),this.getMap().addControl(this.vSwipeControl_)):this.vSwipeControl_&&(this.getMap().removeControl(this.vSwipeControl_),this.vSwipeControl_=void 0)},ComparisonTools.prototype.onHorizontalControlChange_=function(e){e.active?(this.hSwipeControl_=new SwipeControl({layers:this.getLeftLayer(),rightLayers:this.getRightLayer(),orientation:"horizontal"}),this.hSwipeControl_.set("name","hSlider"),this.getMap().addControl(this.hSwipeControl_)):this.hSwipeControl_&&(this.getMap().removeControl(this.hSwipeControl_),this.hSwipeControl_=void 0)},ComparisonTools.prototype.onScopeControlChange_=function(e){let t=this.getControl("scopeToggle");e.active?(t.setInteraction(new ClipInteraction({radius:200})),this.getMap().addInteraction(t.getInteraction()),t.getInteraction().addLayer(this.getRightLayer())):t.getInteraction()&&(t.getInteraction().removeLayer(this.getRightLayer()),this.getMap().removeInteraction(t.getInteraction()),t.setInteraction())},ComparisonTools.prototype.onClipLayerControlChange_=function(e){let t=this.getControl("clipLayerToggle");e.active?(this.getRightLayer().setVisible(!1),t.element.getElementsByClassName("fa")[0].className="fa fa-eye-slash"):(this.useCloneLayer_?"doubleMap"!==this.getDisplayMode()&&this.getRightLayer().setVisible(!0):this.getRightLayer().setVisible(!0),t.element.getElementsByClassName("fa")[0].className="fa fa-eye")},ComparisonTools.prototype.onDoubleMapControlChange_=function(e){let t=this.getMap().getViewport().parentElement,o=this.getClonedMap().getViewport().parentElement;e.active?(o.style.float="left",o.style.width="50%",t.style.width="50%",t.style.float="left",o.style.display="block",o.style.height=t.clientHeight+"px",this.useCloneLayer_?(this.clonedLayer_=new TileLayer(this.getRightLayer().getProperties()),this.clonedLayer_.setVisible(!0),this.getRightLayer().setVisible(!1),this.getRightLayer().on("change",this.updateClonedLayer_,this),this.getClonedMap().addLayer(this.clonedLayer_)):(this.getRightLayer().setVisible(!0),this.layerGroup_.getLayers().remove(this.getRightLayer()),this.getClonedMap().addLayer(this.getRightLayer())),this.getMap().updateSize(),this.getClonedMap().updateSize()):(o.style.display="none",o.style.width="100%",t.style.width="100%",this.useCloneLayer_?(this.getClonedMap().removeLayer(this.clonedLayer_),"clipLayer"!==this.getDisplayMode()&&this.getRightLayer().setVisible(!0),this.getRightLayer().un("change",this.updateClonedLayer_,this)):("clipLayer"!==this.getDisplayMode()&&this.getRightLayer().setVisible(!0),this.getClonedMap().removeLayer(this.getRightLayer()),this.layerGroup_.getLayers().push(this.getRightLayer()))),this.getMap().updateSize()},ComparisonTools.prototype.setDisplayMode=function(e){if(!this.getMap())throw new EvalError("control must be added to map before setting displayMode.");"vSlider"===e?this.getControl("vSliderToggle").setActive(!0):"hSlider"===e?this.getControl("hSliderToggle").setActive(!0):"scope"===e?this.getControl("scopeToggle").setActive(!0):"clipLayer"===e?this.getControl("clipLayerToggle").setActive(!0):"doubleMap"===e&&this.getControl("doubleMapToggle").setActive(!0)},ComparisonTools.prototype.getDisplayMode=function(){for(let e=0;e<this.getControls().length;e++)if(this.getControls()[e].getActive())return this.getControls()[e].get("name").substring(0,this.getControls()[e].get("name").length-6);return"normal"},ComparisonTools.prototype.setRightLayer=function(e){if(!this.getMap())throw new EvalError("control must be added to map before setting rightLayer.");if("vSlider"===this.getDisplayMode()){let t;this.getMap().getControls().forEach(function(e){"vSlider"===e.get("name")&&(t=e)}),t.removeLayer(this.getRightLayer()),t.addLayer(e,!0)}else if("hSlider"===this.getDisplayMode()){let t;this.getMap().getControls().forEach(function(e){"hSlider"===e.get("name")&&(t=e)}),t.removeLayer(this.getRightLayer()),t.addLayer(e,!0)}else if("clipLayer"===this.getDisplayMode())e.setVisible(this.getRightLayer().getVisible());else if("scope"===this.getDisplayMode()){let t=this.getControl("scopeToggle").getInteraction();t.removeLayer(this.getRightLayer()),t.addLayer(e)}else"doubleMap"===this.getDisplayMode()&&(this.useCloneLayer_?(this.clonedLayer_.setProperties(e.getProperties()),this.getRightLayer().on("change",this.updateClonedLayer_,this),this.getRightLayer().setVisible(!1)):(this.getRightLayer().setVisible(!0),this.layerGroup_.getLayers().remove(e),this.getClonedMap().getLayers().forEach(function(t,o){t===this.getRightLayer()&&this.getClonedMap().getLayers().setAt(o,e)},this)));this.rightLayer_=e},ComparisonTools.prototype.updateClonedLayer_=function(){this.clonedLayer_.setProperties(this.getRightLayer().getProperties()),this.clonedLayer_.setVisible(!0)},ComparisonTools.prototype.setLeftLayer=function(e){if(!this.getMap())throw new EvalError("control must be added to map before setting leftLayer.");let t,o;this.leftLayer_=e,this.getMap().getControls().forEach(function(e){"vSlider"===e.get("name")&&(t=e)}),t&&t.addLayer(this.getLeftLayer()),this.getMap().getControls().forEach(function(e){"hSlider"===e.get("name")&&(o=e)}),o&&o.addLayer(this.getLeftLayer())},ComparisonTools.prototype.getRightLayer=function(){return this.rightLayer_},ComparisonTools.prototype.getLeftLayer=function(){return this.leftLayer_},ComparisonTools.prototype.getClonedMap=function(){return this.clonedMap_},ComparisonTools.prototype.setLayerGroup=function(e){this.layerGroup_=e},ComparisonTools.prototype.getLayerGroup=function(){return this.layerGroup_},ComparisonTools.prototype.getVSwipeControl=function(){return this.vSwipeControl_},ComparisonTools.prototype.getHSwipeControl=function(){return this.hSwipeControl_};const HistogramMatchingControl=function(e){e||(e={}),this.layer1_=e.layer1,this.layer2_=e.layer2,this.classCount_=e.classCount?e.classCount:1e3,this.layerProcessed_={},this.active_=!1,ToggleControl.call(this,{html:'<i class="fa fa-bar-chart"></i>',className:"ol-histogram-matching",title:"Adaptation d'histogramme",active:!1})};ol.inherits(HistogramMatchingControl,ToggleControl),HistogramMatchingControl.prototype.setMap=function(e){Control.prototype.setMap.call(this,e),this.on("change:active",this.onToggle_)},HistogramMatchingControl.prototype.onToggle_=function(e){let t=this;if($(t.element).find("button").blur(),!0===t.getActive()){let e=new RasterSource({sources:[t.layer1_.getSource(),t.layer2_.getSource()],operationType:"image",operation:t.rasterOperation_,lib:{computeHistogram:t.computeHistogram_,getInverseClassIndex:t.getInverseClassIndex_,getInverseValue:t.getInverseValue_,classCount:t.classCount_}});t.layerProcessed_=new ImageLayer({source:e,name:"processedLayer"}),t.getMap().addLayer(t.layerProcessed_),t.getMap().on("moveend",function(){e.changed()})}else t.getMap().removeLayer(t.layerProcessed_),t.getMap().render()},HistogramMatchingControl.prototype.rasterOperation_=function(e,t){let o=e[0],i=e[1],r=computeHistogram(i),n=computeHistogram(o);if(0===n.count||void 0===r||0===r.count)return{data:o.data,width:o.width,height:o.height};let a=a||{},l=o.width,s=o.height,h=(a.x&&a.x,a.y&&a.y,o.data),u=new Uint8ClampedArray(h.length);for(let e=0,t=0;e<s;++e){for(let e=0;e<l;++e,t+=4){let e=h[t],o=h[t+1],i=h[t+2],a=(h[t+3],t);u[a]=getInverseValue(n.cumulative_red[Math.round(Math.max(0,Math.min(255,e)))],r.inverse_red),u[a+1]=getInverseValue(n.cumulative_green[Math.round(Math.max(0,Math.min(255,o)))],r.inverse_green),u[a+2]=getInverseValue(n.cumulative_blue[Math.round(Math.max(0,Math.min(255,i)))],r.inverse_blue),u[a+3]=255}}return{data:u,width:l,height:s}},HistogramMatchingControl.prototype.setLayer1=function(e){this.layer1_=e},HistogramMatchingControl.prototype.setLayer2=function(e){this.layer2_=e},HistogramMatchingControl.prototype.getInverseClassIndex_=function(e){let t=Math.floor(e*classCount);return t=Math.max(0,Math.min(t,classCount-1))},HistogramMatchingControl.prototype.getInverseValue_=function(e,t){if(null==t)throw"inverse values cannot be undefined";let o=getInverseClassIndex(e);if(null==t[o]){let e=o-1;for(;e>=0&&null==t[e];)e--;e<0&&(e=null);let i=o+1;for(;i<classCount&&null==t[i];)i++;if(i>=classCount&&(i=null),null==e)for(let e=0;e<i;e++)t[e]=t[i];else if(null==i)for(let o=e+1;o<classCount;o++)t[o]=t[e];else for(let o=e+1;o<i;o++){let r=(o-e)/(i-e);t[o]=(1-r)*t[e]+r*t[i]}}return t[o]},HistogramMatchingControl.prototype.computeHistogram_=function(e){let t={red:new Array(256),cumulative_red:new Array(256),inverse_red:new Array(classCount),green:new Array(256),cumulative_green:new Array(256),inverse_green:new Array(classCount),blue:new Array(256),cumulative_blue:new Array(256),inverse_blue:new Array(classCount),count:0};for(let e=0;e<256;e++)t.red[e]=t.green[e]=t.blue[e]=0;let o=e.data,i=e.width,r=e.height;for(let e=0,n=0;e<r;++e){for(let e=0;e<i;++e,n+=4)t.red[o[n]]+=1,t.green[o[n+1]]+=1,t.blue[o[n+2]]+=1,t.count++}if(t.count<1e-4)throw"Cannot compute cumulative histogram. Count is quite zero...";t.cumulative_red[0]=t.red[0]/t.count,t.cumulative_green[0]=t.green[0]/t.count,t.cumulative_blue[0]=t.blue[0]/t.count;for(let e=1;e<256;e++)t.cumulative_red[e]=t.cumulative_red[e-1]+t.red[e]/t.count,t.cumulative_green[e]=t.cumulative_green[e-1]+t.green[e]/t.count,t.cumulative_blue[e]=t.cumulative_blue[e-1]+t.blue[e]/t.count;for(let e=0;e<classCount;e++)t.inverse_red[e]=t.inverse_green[e]=t.inverse_blue[e]=null;for(let e=0;e<255;e++)t.inverse_red[getInverseClassIndex(t.cumulative_red[e])]=e,t.inverse_green[getInverseClassIndex(t.cumulative_green[e])]=e,t.inverse_blue[getInverseClassIndex(t.cumulative_blue[e])]=e;return t},HistogramMatchingControl.prototype.getLayerProcessed=function(){return this.layerProcessed_};const Histogram=function(){function e(){this.count=0,this.red=null,this.green=null,this.blue=null,this.modified=!1,this.cumulative_red=null,this.cumulative_green=null,this.cumulative_blue=null,this.inverse_red=null,this.inverse_green=null,this.inverse_blue=null,this.count=0,this.red=new Array(256),this.green=new Array(256),this.blue=new Array(256);for(let e=0;e<256;e++)this.red[e]=this.green[e]=this.blue[e]=0}return e.prototype.computeFromContext=function(e){let t=e.canvas,o=t.width,i=t.height,r=e.getImageData(0,0,o,i).data;for(let e=0,t=0;e<i;++e){for(let e=0;e<o;++e,t+=4)this.red[r[t]]+=1,this.green[r[t+1]]+=1,this.blue[r[t+2]]+=1,this.count++}this.invalidatePrecomputation()},e.prototype.computeFromCroppedContext=function(e,t){let o=e.canvas,i=t.width?t.width:o.width,r=t.height?t.height:o.height,n=t.x?t.x:0,a=t.y?t.y:0,l=e.getImageData(n,a,i,r).data;for(let e=0,t=0;e<r;++e){for(let e=0;e<i;++e,t+=4)this.red[l[t]]+=1,this.green[l[t+1]]+=1,this.blue[l[t+2]]+=1,this.count++}this.invalidatePrecomputation()},e.prototype.compute=function(e){let t={red:[],green:[],blue:[],count:0},o=e.data,i=e.width,r=e.height;for(let e=0,n=0;e<r;++e){for(let e=0;e<i;++e,n+=4)t.red[o[n]]+=1,t.green[o[n+1]]+=1,t.blue[o[n+2]]+=1,t.count++}return t},e.prototype.computeCumulative=function(){if(this.count<1e-4)throw"Cannot compute cumulative histogram. Count is quite zero...";this.cumulative_red=new Array(256),this.cumulative_green=new Array(256),this.cumulative_blue=new Array(256),this.cumulative_red[0]=this.red[0]/this.count,this.cumulative_green[0]=this.green[0]/this.count,this.cumulative_blue[0]=this.blue[0]/this.count;for(let e=1;e<256;e++)this.cumulative_red[e]=this.cumulative_red[e-1]+this.red[e]/this.count,this.cumulative_green[e]=this.cumulative_green[e-1]+this.green[e]/this.count,this.cumulative_blue[e]=this.cumulative_blue[e-1]+this.blue[e]/this.count},e.prototype.invalidatePrecomputation=function(){this.inverse_red=null,this.inverse_green=null,this.inverse_blue=null,this.cumulative_red=null,this.cumulative_green=null,this.cumulative_blue=null},e.prototype.getInverseClassIndex=function(t){let o=Math.floor(t*e.INVERSE_CLASS_COUNT);return o=Math.max(0,Math.min(o,e.INVERSE_CLASS_COUNT-1))},e.prototype.getInverseValue=function(t,o){if(null==o)throw"inverse values cannot be undefined";let i=this.getInverseClassIndex(t);if(null==o[i]){let t=i-1;for(;t>=0&&null==o[t];)t--;t<0&&(t=null);let r=i+1;for(;r<e.INVERSE_CLASS_COUNT&&null==o[r];)r++;if(r>=e.INVERSE_CLASS_COUNT&&(r=null),null==t)for(let e=0;e<r;e++)o[e]=o[r];else if(null==r)for(let i=t+1;i<e.INVERSE_CLASS_COUNT;i++)o[i]=o[t];else for(let e=t+1;e<r;e++){let i=(e-t)/(r-t);o[e]=(1-i)*o[t]+i*o[r]}}return o[i]},e.prototype.getRedCount=function(e){if(null==this.red)throw"Histogram has not yet been filled with any pixel...";return this.red[Math.round(Math.max(0,Math.min(255,e)))]},e.prototype.getGreenCount=function(e){if(null==this.green)throw"Histogram has not yet been filled with any pixel...";return this.green[Math.round(Math.max(0,Math.min(255,e)))]},e.prototype.getBlueCount=function(e){if(null==this.blue)throw"Histogram has not yet been filled with any pixel...";return this.blue[Math.round(Math.max(0,Math.min(255,e)))]},e.prototype.getCumulativeRed=function(e){return null==this.cumulative_red&&this.computeCumulative(),this.cumulative_red[Math.round(Math.max(0,Math.min(255,e)))]},e.prototype.getCumulativeGreen=function(e){return null==this.cumulative_green&&this.computeCumulative(),this.cumulative_green[Math.round(Math.max(0,Math.min(255,e)))]},e.prototype.getCumulativeBlue=function(e){return null==this.cumulative_blue&&this.computeCumulative(),this.cumulative_blue[Math.round(Math.max(0,Math.min(255,e)))]},e.prototype.getInverseRedCount=function(e){return null==this.inverse_red&&this.computeInverse(),this.getInverseValue(e,this.inverse_red)},e.prototype.getInverseGreenCount=function(e){return null==this.inverse_green&&this.computeInverse(),this.getInverseValue(e,this.inverse_green)},e.prototype.getInverseBlueCount=function(e){return null==this.inverse_blue&&this.computeInverse(),this.getInverseValue(e,this.inverse_blue)},e.prototype.computeInverse=function(){this.inverse_red=new Array(e.INVERSE_CLASS_COUNT),this.inverse_green=new Array(e.INVERSE_CLASS_COUNT),this.inverse_blue=new Array(e.INVERSE_CLASS_COUNT);for(let t=0;t<e.INVERSE_CLASS_COUNT;t++)this.inverse_red[t]=this.inverse_green[t]=this.inverse_blue[t]=null;for(let e=0;e<255;e++)this.inverse_red[this.getInverseClassIndex(this.getCumulativeRed(e))]=e,this.inverse_green[this.getInverseClassIndex(this.getCumulativeGreen(e))]=e,this.inverse_blue[this.getInverseClassIndex(this.getCumulativeBlue(e))]=e},e.INVERSE_CLASS_COUNT=1e3,e}();